<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Mini Crossword</title>
  <!-- Tailwind (Play CDN) -->
  <script src="https://cdn.tailwindcss.com"></script>
  <!-- React + ReactDOM from CDN -->
  <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
  <!-- Babel for in-browser JSX transform -->
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
</head>
<body class="bg-white text-neutral-900">
  <div id="root"></div>

  <script type="text/babel">
    const { useMemo, useState, useEffect, useRef } = React;

    // --- Utilities ---
    const clone = (x) => JSON.parse(JSON.stringify(x));
    const DIRS = { ACROSS: "across", DOWN: "down" };
    const pad = (n)=> (n<10 ? "0"+n : ""+n);

    // --- Puzzle bank (English-only). Two clue sets rotate on refresh. ---
    // Grid pattern (5x5):
    // LIMIT
    // AN#MI
    // STEAM
    // ER#GO
    // ROVER
    //
    // Downs: LASER / INTRO / IMAGE / TIMOR
    const PUZZLE_BANK = [
      {
        id: "limit-steam-v1",
        title: "Daily Mini",
        author: "Rosh",
        date: "",
        size: 5,
        grid: ["LIMIT","AN#MI","STEAM","ER#GO","ROVER"],
        clues: {
          across: {
            "1": "Cap; constrain",
            "6": "Indefinite article",
            "7": "Note between ‘re’ and ‘fa’",
            "8": "Power for old locomotives",
            "9": "Hesitation sound",
            "10": "Proceed",
            "11": "Mars explorer, e.g."
          },
          down: {
            "1": "Barcode scanner beam",
            "2": "Album opener",
            "3": "Picture",
            "4": "Eastern half of a Southeast Asian island"
          }
        }
      },
      {
        id: "limit-steam-v2",
        title: "Daily Mini",
        author: "Rosh",
        date: "",
        size: 5,
        grid: ["LIMIT","AN#MI","STEAM","ER#GO","ROVER"],
        clues: {
          across: {
            "1": "Upper bound",
            "6": "Grammar bit before a vowel sound",
            "7": "Sol-fa syllable after ‘re’",
            "8": "Kettle output",
            "9": "“Uh …” cousin",
            "10": "Get moving",
            "11": "Curiosity, for one"
          },
          down: {
            "1": "Cutting-edge beam",
            "2": "Track zero on some albums",
            "3": "Likeness",
            "4": "____-Leste (country in Asia)"
          }
        }
      }
    ];

    // --- Crossword mechanics (unchanged core) ---
    function generateMeta(grid) {
      const N = grid.length;
      const numbering = Array.from({ length: N }, () => Array(N).fill(null));
      let num = 0;
      for (let r = 0; r < N; r++) {
        for (let c = 0; c < N; c++) {
          const ch = grid[r][c];
          if (ch !== "#") {
            const startA = (c===0 || grid[r][c-1]==="#") && c+1<N && grid[r][c+1]!=="#";
            const startD = (r===0 || grid[r-1][c]==="#") && r+1<N && grid[r+1][c]!=="#";
            if (startA || startD) numbering[r][c] = ++num;
          }
        }
      }
      const across=[], down=[];
      for (let r=0;r<N;r++){
        let c=0;
        while(c<N){
          if (grid[r][c]!=="#" && (c===0 || grid[r][c-1]==="#")){
            const start=c; let s="";
            while(c<N && grid[r][c]!=="#"){ s+=grid[r][c]; c++; }
            if (s.length>1) across.push({ number:numbering[r][start], row:r, col:start, length:s.length, answer:s });
          } else c++;
        }
      }
      for (let c=0;c<N;c++){
        let r=0;
        while(r<N){
          if (grid[r][c]!=="#" && (r===0 || grid[r-1][c]==="#")){
            const start=r; let s="";
            while(r<N && grid[r][c]!=="#"){ s+=grid[r][c]; r++; }
            if (s.length>1) down.push({ number:numbering[start][c], row:start, col:c, length:s.length, answer:s });
          } else r++;
        }
      }
      return { N, numbering, across, down };
    }
    const emptyUserGridFrom = (grid) => grid.map((row) => row.replace(/[^#]/g, " "));
    const setCharAt = (str, idx, ch) => str.substring(0, idx) + ch + str.substring(idx + 1);
    const inBounds = (N, r, c) => r>=0 && r<N && c>=0 && c<N;
    const nextCell = ({ N, grid, r, c, dir }) => {
      const step = dir==="across" ? [0,1] : [1,0];
      let nr=r+step[0], nc=c+step[1];
      while (inBounds(N,nr,nc) && grid[nr][nc]==="#") { nr+=step[0]; nc+=step[1]; }
      return inBounds(N,nr,nc) ? { r:nr, c:nc } : null;
    };
    const prevCell = ({ N, grid, r, c, dir }) => {
      const step = dir==="across" ? [0,-1] : [-1,0];
      let nr=r+step[0], nc=c+step[1];
      while (inBounds(N,nr,nc) && grid[nr][nc]==="#") { nr+=step[0]; nc+=step[1]; }
      return inBounds(N,nr,nc) ? { r:nr, c:nc } : null;
    };

    function usePuzzle(initialPuzzle) {
      const [puzzle, setPuzzle] = useState(() => clone(initialPuzzle));
      const meta = useMemo(() => generateMeta(puzzle.grid), [puzzle.grid]);
      const [userGrid, setUserGrid] = useState(() => emptyUserGridFrom(puzzle.grid));
      const [dir, setDir] = useState(DIRS.ACROSS);
      const [active, setActive] = useState(() => ({ r:0, c:0 }));
      const [checked, setChecked] = useState(false);
      useEffect(() => {
        setUserGrid(emptyUserGridFrom(puzzle.grid));
        setChecked(false);
        // focus first non-block
        outer: for (let r=0;r<meta.N;r++) for (let c=0;c<meta.N;c++) if (puzzle.grid[r][c]!=="#"){ setActive({r,c}); break outer; }
      }, [puzzle.id]);
      return { puzzle, setPuzzle, meta, userGrid, setUserGrid, dir, setDir, active, setActive, checked, setChecked };
    }

    function getCurrentRun(meta, dir, r, c) {
      const runs = dir===DIRS.ACROSS ? meta.across : meta.down;
      for (const run of runs) {
        if (dir===DIRS.ACROSS) {
          if (r===run.row && c>=run.col && c<run.col+run.length) return run;
        } else {
          if (c===run.col && r>=run.row && r<run.row+run.length) return run;
        }
      }
      return null;
    }
    const coordsOfRun = (run, dir) => {
      if (!run) return [];
      return Array.from({length: run.length}, (_,i) =>
        dir===DIRS.ACROSS ? { r: run.row, c: run.col+i } : { r: run.row+i, c: run.col }
      );
    };

    function MiniCell({ cell, isActive, inActiveWord, userCh, correct, disabled, onClick }) {
      if (cell.ch === "#") return <div className="bg-neutral-900 rounded-md" />;
      const base = "relative rounded-md border text-center flex items-center justify-center select-none aspect-square";
      const color = disabled ? "border-neutral-300 bg-neutral-100"
                  : isActive ? "border-indigo-500 ring-2 ring-indigo-300"
                  : inActiveWord ? "border-indigo-300"
                  : "border-neutral-300";
      const wrong = correct === false ? "bg-red-50" : "";
      const right = correct === true ? "bg-green-50" : "";
      return (
        <button onClick={onClick} disabled={disabled}
          className={`${base} ${color} ${wrong} ${right}`} aria-label={`Cell`}>
          {cell.num && (<span className="absolute top-0.5 left-1 text-[10px] text-neutral-500 select-none">{cell.num}</span>)}
          <span className="text-xl font-semibold tracking-wide">{(userCh || " ")}</span>
        </button>
      );
    }

    function Controls({ onClear, onCheck, onRevealRun, onRevealAll, onImport, onExport, onNew, timeLeft, disabled }) {
      const [importText, setImportText] = useState("");
      const mins = Math.floor(timeLeft/60), secs = timeLeft%60;
      return (
        <div className="flex flex-wrap items-center gap-2">
          <div className="px-3 py-1 rounded-md border bg-white font-mono text-sm">
            ⏱ {pad(mins)}:{pad(secs)}
          </div>
          <button className="px-3 py-1 rounded-md border bg-white" onClick={onNew}>New puzzle</button>
          <div className="w-px h-6 bg-neutral-300 mx-1" />
          <button className="px-3 py-1 rounded-md border bg-white" onClick={onClear} disabled={disabled}>Clear</button>
          <button className="px-3 py-1 rounded-md border bg-white" onClick={onCheck} disabled={disabled}>Check</button>
          <button className="px-3 py-1 rounded-md border bg-white" onClick={onRevealRun}>Reveal Word</button>
          <button className="px-3 py-1 rounded-md border bg-white" onClick={onRevealAll}>Reveal All</button>
          <details className="ml-2">
            <summary className="cursor-pointer px-3 py-1 rounded-md border bg-white inline-block">Import / Export</summary>
            <div className="mt-2 p-3 border rounded-md bg-neutral-50 w-[480px] max-w-[90vw]">
              <div className="text-sm mb-1 font-medium">Import JSON</div>
              <textarea className="w-full h-28 p-2 border rounded-md text-xs font-mono" placeholder='{"id":"mine","size":5,"grid":["#####",...],"clues":{"across":{},"down":{}}}' value={importText} onChange={(e)=>setImportText(e.target.value)} />
              <div className="flex gap-2 mt-2">
                <button className="px-3 py-1 rounded-md border bg-white" onClick={()=>onImport(importText)}>Import</button>
                <button className="px-3 py-1 rounded-md border bg-white" onClick={onExport}>Export Current</button>
              </div>
            </div>
          </details>
        </div>
      );
    }

    function Overlay({ title, subtitle, primary, secondary }) {
      return (
        <div className="fixed inset-0 bg-black/40 flex items-center justify-center z-50">
          <div className="bg-white rounded-xl shadow-xl p-6 w-[420px] max-w-[90vw] text-center">
            <h2 className="text-xl font-semibold">{title}</h2>
            {subtitle && <p className="text-neutral-600 mt-1">{subtitle}</p>}
            <div className="mt-4 flex items-center justify-center gap-2">
              {primary}
              {secondary}
            </div>
          </div>
        </div>
      );
    }

    function MiniCrosswordApp() {
      // pick a random English puzzle on load
      const [seed] = useState(() => Math.random());
      const startIndex = Math.floor(seed * PUZZLE_BANK.length) % PUZZLE_BANK.length;
      const [puzzleIndex, setPuzzleIndex] = useState(startIndex);
      const basePuzzle = PUZZLE_BANK[puzzleIndex];

      const { puzzle, setPuzzle, meta, userGrid, setUserGrid, dir, setDir, active, setActive, checked, setChecked } = usePuzzle(basePuzzle);

      // 10-minute countdown
      const [timeLeft, setTimeLeft] = useState(600);        // 600s = 10:00
      const [timeUp, setTimeUp] = useState(false);
      const [solved, setSolved] = useState(false);

      // tick timer
      useEffect(() => {
        if (timeUp || solved) return;
        const t = setInterval(() => setTimeLeft(x => {
          if (x <= 1) { clearInterval(t); setTimeUp(true); return 0; }
          return x-1;
        }), 1000);
        return () => clearInterval(t);
      }, [timeUp, solved]);

      // detect solved
      useEffect(() => {
        const N = meta.N;
        for (let r=0;r<N;r++){
          for (let c=0;c<N;c++){
            const sol = puzzle.grid[r][c];
            const usr = userGrid[r][c];
            if (sol === '#') continue;
            if (usr !== sol) { setSolved(false); return; }
          }
        }
        setSolved(true);
      }, [userGrid, puzzle.grid]);

      const N = meta.N;
      const activeRun = getCurrentRun(meta, dir, active.r, active.c);
      const activeCoords = coordsOfRun(activeRun, dir);
      const gridRef = useRef(null);

      // keyboard play (disabled if timeUp or solved)
      useEffect(() => {
        const el = gridRef.current; if (!el) return;
        const handler = (e) => {
          if (timeUp || solved) return;
          if (!el.contains(document.activeElement)) return;
          const key = e.key;
          if (/^[a-zA-Z]$/.test(key)) {
            e.preventDefault();
            if (puzzle.grid[active.r][active.c] === '#') return;
            const next = [...userGrid];
            next[active.r] = setCharAt(next[active.r], active.c, key.toUpperCase());
            setUserGrid(next);
            setChecked(false);
            const nxt = nextCell({ N, grid: puzzle.grid, r: active.r, c: active.c, dir });
            if (nxt) setActive(nxt);
            return;
          }
          if (key === 'Backspace') {
            e.preventDefault();
            const next = [...userGrid];
            const has = userGrid[active.r][active.c] !== ' ' && puzzle.grid[active.r][active.c] !== '#';
            if (has) {
              next[active.r] = setCharAt(next[active.r], active.c, ' ');
              setUserGrid(next);
            } else {
              const prv = prevCell({ N, grid: puzzle.grid, r: active.r, c: active.c, dir });
              if (prv) {
                next[prv.r] = setCharAt(next[prv.r], prv.c, ' ');
                setUserGrid(next);
                setActive(prv);
              }
            }
            setChecked(false);
            return;
          }
          if (key === ' ') { e.preventDefault(); setDir(d => d===DIRS.ACROSS ? DIRS.DOWN : DIRS.ACROSS); return; }
          if (key === 'Enter') {
            e.preventDefault();
            const runs = dir === DIRS.ACROSS ? meta.across : meta.down;
            if (!activeRun) return;
            const idx = runs.findIndex(r => r.number === activeRun.number);
            const nextRun = runs[(idx + 1) % runs.length];
            setActive({ r: nextRun.row, c: nextRun.col });
            return;
          }
          const mv = (dr, dc) => {
            e.preventDefault();
            const nr = Math.max(0, Math.min(N - 1, active.r + dr));
            const nc = Math.max(0, Math.min(N - 1, active.c + dc));
            if (puzzle.grid[nr][nc] !== '#') setActive({ r: nr, c: nc });
          };
          if (key === 'ArrowUp') return mv(-1, 0);
          if (key === 'ArrowDown') return mv(1, 0);
          if (key === 'ArrowLeft') return mv(0, -1);
          if (key === 'ArrowRight') return mv(0, 1);
        };
        document.addEventListener('keydown', handler);
        return () => document.removeEventListener('keydown', handler);
      }, [active, dir, userGrid, puzzle.grid, meta, timeUp, solved]);

      // actions
      const clearAll = () => { if (timeUp) return; setUserGrid(emptyUserGridFrom(puzzle.grid)); setChecked(false); };
      const check = () => { if (timeUp) return; setChecked(true); };
      const revealRun = () => {
        if (!activeRun) return;
        const { row, col, length } = activeRun;
        const next = [...userGrid];
        if (dir === DIRS.ACROSS) {
          for (let i=0;i<length;i++) next[row] = setCharAt(next[row], col+i, puzzle.grid[row][col+i]);
        } else {
          for (let i=0;i<length;i++) next[row+i] = setCharAt(next[row+i], col, puzzle.grid[row+i][col]);
        }
        setUserGrid(next);
      };
      const revealAll = () => setUserGrid(puzzle.grid.map(r => r.replace(/#/g, '#')));
      const newPuzzle = () => {
        const next = (puzzleIndex + 1 + Math.floor(Math.random()*PUZZLE_BANK.length)) % PUZZLE_BANK.length;
        setPuzzle(clone(PUZZLE_BANK[next]));
        setPuzzleIndex(next);
        setUserGrid(emptyUserGridFrom(PUZZLE_BANK[next].grid));
        setTimeLeft(600); setTimeUp(false); setSolved(false); setChecked(false);
      };

      // UI bits
      const correctness = useMemo(() => {
        if (!checked) return null;
        const mark = Array.from({ length: N }, () => Array(N).fill(null));
        for (let r=0;r<N;r++){
          for (let c=0;c<N;c++){
            const sol = puzzle.grid[r][c];
            const usr = userGrid[r][c];
            if (sol === '#') { mark[r][c] = null; continue; }
            if (usr === ' ') { mark[r][c] = false; continue; }
            mark[r][c] = usr === sol;
          }
        }
        return mark;
      }, [checked, userGrid, puzzle.grid]);

      const header = (
        <div className="flex items-end justify-between gap-4">
          <div>
            <h1 className="text-2xl font-semibold">{puzzle.title || 'Mini Crossword'}</h1>
            <div className="text-sm text-neutral-500">{puzzle.author ? `by ${puzzle.author}` : ''}</div>
          </div>
          <Controls
            onClear={clearAll}
            onCheck={check}
            onRevealRun={revealRun}
            onRevealAll={revealAll}
            onImport={(text)=>{ try { const obj = JSON.parse(text); if (!obj.id) obj.id = `import-${Date.now()}`; if (!obj.size || obj.grid?.length !== obj.size) throw new Error('Grid size mismatch'); setPuzzle(obj); setTimeLeft(600); setTimeUp(false); setSolved(false); setChecked(false);} catch(e){ alert('Import failed: '+e.message); } }}
            onExport={()=>{ const data = JSON.stringify(puzzle, null, 2); const a = document.createElement('a'); a.href = URL.createObjectURL(new Blob([data], { type: 'application/json' })); a.download = `${puzzle.title || puzzle.id}.json`; a.click(); }}
            onNew={newPuzzle}
            timeLeft={timeLeft}
            disabled={timeUp || solved}
          />
        </div>
      );

      return (
        <div className="p-6 max-w-5xl mx-auto">
          {header}
          <div ref={gridRef} tabIndex={0} className="mt-6 grid grid-cols-1 lg:grid-cols-[minmax(0,400px)_1fr] gap-8 items-start outline-none"
               onKeyDown={(e)=>{ if(e.key===' ') e.preventDefault(); }}>
            <div>
              <div className="grid" style={{ gridTemplateColumns: `repeat(${N}, minmax(0, 1fr))`, gap: '4px' }}>
                {meta.numbering.flatMap((rowNums, r) =>
                  rowNums.map((num, c) => {
                    const cell = { ch: puzzle.grid[r][c], num, row: r, col: c };
                    const isActive = active.r === r && active.c === c;
                    const inActiveWord = (activeCoords || []).some(k => k.r===r && k.c===c);
                    const correctMark = correctness ? correctness[r][c] : null;
                    return (
                      cell.ch==="#"
                        ? <div key={`b-${r}-${c}`} className="bg-neutral-900 rounded-md" />
                        : <MiniCell
                            key={`p-${r}-${c}`}
                            cell={cell}
                            isActive={isActive}
                            inActiveWord={inActiveWord}
                            userCh={userGrid[r][c]==="#" ? '' : userGrid[r][c]}
                            correct={correctMark}
                            disabled={timeUp || solved}
                            onClick={()=>{
                              if (puzzle.grid[r][c] === '#') return;
                              if (timeUp || solved) return;
                              if (active.r === r && active.c === c) setDir(d => d===DIRS.ACROSS ? DIRS.DOWN : DIRS.ACROSS);
                              else setActive({ r, c });
                            }}
                          />
                    );
                  })
                )}
              </div>
              <div className="mt-2 text-xs text-neutral-500">Type letters. Space = toggle direction. Enter = next clue. Arrows = move.</div>
            </div>
            <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
              <div>
                <h3 className="text-sm uppercase tracking-wide text-neutral-500 mb-2">Across</h3>
                <div className="space-y-1">
                  {meta.across.map(run=>{
                    const clue = puzzle.clues?.across?.[run.number] || "(clue)";
                    return (
                      <div key={`A-${run.number}`} className="px-3 py-2 rounded-md border bg-white">
                        <div className="text-[11px] text-neutral-500">{run.number}</div>
                        <div className="text-sm leading-snug">{clue}</div>
                        <div className="text-[11px] text-neutral-400 mt-0.5">{run.length} letters</div>
                      </div>
                    );
                  })}
                </div>
              </div>
              <div>
                <h3 className="text-sm uppercase tracking-wide text-neutral-500 mb-2">Down</h3>
                <div className="space-y-1">
                  {meta.down.map(run=>{
                    const clue = puzzle.clues?.down?.[run.number] || "(clue)";
                    return (
                      <div key={`D-${run.number}`} className="px-3 py-2 rounded-md border bg-white">
                        <div className="text-[11px] text-neutral-500">{run.number}</div>
                        <div className="text-sm leading-snug">{clue}</div>
                        <div className="text-[11px] text-neutral-400 mt-0.5">{run.length} letters</div>
                      </div>
                    );
                  })}
                </div>
              </div>
            </div>
          </div>

          {/* Overlays */}
          {timeUp && (
            <Overlay
              title="Time’s up!"
              subtitle="Want to see the grid or try a new one?"
              primary={<button className="px-4 py-2 rounded-md bg-indigo-600 text-white" onClick={()=>{ setUserGrid(puzzle.grid.map(r => r.replace(/#/g, '#'))); }}>Reveal solution</button>}
              secondary={<button className="px-4 py-2 rounded-md border" onClick={newPuzzle}>New puzzle</button>}
            />
          )}
          {(!timeUp && solved) && (
            <Overlay
              title="Nice solve! 🎉"
              subtitle={`Finished with ${pad(Math.floor(timeLeft/60))}:${pad(timeLeft%60)} left`}
              primary={<button className="px-4 py-2 rounded-md bg-indigo-600 text-white" onClick={newPuzzle}>New puzzle</button>}
              secondary={<button className="px-4 py-2 rounded-md border" onClick={()=>setChecked(true)}>Check grid</button>}
            />
          )}
        </div>
      );
    }

    const root = ReactDOM.createRoot(document.getElementById("root"));
    root.render(<MiniCrosswordApp />);
  </script>
</body>
</html>
