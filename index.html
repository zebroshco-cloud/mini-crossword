<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Mini Crossword</title>
  <!-- Tailwind (Play CDN) -->
  <script src="https://cdn.tailwindcss.com"></script>
  <!-- React + ReactDOM from CDN -->
  <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
  <!-- Babel for in-browser JSX transform -->
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <style>html,body{height:100%}</style>
</head>
<body class="bg-white text-neutral-900">
  <noscript style="display:block;padding:16px;color:#b91c1c">
    This page needs JavaScript enabled to run.
  </noscript>

  <!-- MOUNT NODE -->
  <div id="root" class="min-h-screen"></div>

  <!-- APP -->
  <script type="text/babel">
    const { useMemo, useState, useEffect, useRef } = React;

    const clone = (x) => JSON.parse(JSON.stringify(x));
    const DIRS = { ACROSS: "across", DOWN: "down" };

    const SAMPLE_PUZZLES = [
      {
        id: "sample-1",
        title: "Morning Warmup",
        author: "You",
        date: "2025-08-27",
        size: 5,
        grid: ["CAFE#","AREA#","FRODO","#ECHO","#SOLO"],
        clues: {
          across: {
            "1":"Coffee spot", "3":"Zone or field", "6":"Baggins of the Shire",
            "7":"Sound reflection", "8":"Han ___"
          },
          down: { "1":"Car horn sound", "2":"Exists", "4":"Golf peg", "5":"Not many" }
        }
      }
    ];

    function generateMeta(grid) {
      const N = grid.length;
      const numbering = Array.from({length:N},()=>Array(N).fill(null));
      let num = 0;
      for (let r=0;r<N;r++){
        for (let c=0;c<N;c++){
          const ch = grid[r][c];
          if (ch !== "#") {
            const startA = (c===0 || grid[r][c-1]==="#") && c+1<N && grid[r][c+1]!=="#";
            const startD = (r===0 || grid[r-1][c]==="#") && r+1<N && grid[r+1][c]!=="#";
            if (startA || startD) numbering[r][c] = ++num;
          }
        }
      }
      const across=[], down=[];
      for (let r=0;r<N;r++){
        let c=0;
        while(c<N){
          if(grid[r][c]!=="#" && (c===0 || grid[r][c-1]==="#")){
            const start=c; let s="";
            while(c<N && grid[r][c]!=="#"){ s+=grid[r][c]; c++; }
            if (s.length>1) across.push({number:numbering[r][start],row:r,col:start,length:s.length,answer:s});
          } else c++;
        }
      }
      for (let c=0;c<N;c++){
        let r=0;
        while(r<N){
          if(grid[r][c]!=="#" && (r===0 || grid[r-1][c]==="#")){
            const start=r; let s="";
            while(r<N && grid[r][c]!=="#"){ s+=grid[r][c]; r++; }
            if (s.length>1) down.push({number:numbering[start][c],row:start,col:c,length:s.length,answer:s});
          } else r++;
        }
      }
      return {N, numbering, across, down};
    }

    const setCharAt=(str,i,ch)=>str.substring(0,i)+ch+str.substring(i+1);
    const inBounds=(N,r,c)=>r>=0&&r<N&&c>=0&&c<N;
    const nextCell=({N,grid,r,c,dir})=>{
      const step = dir==="across" ? [0,1] : [1,0];
      let nr=r+step[0], nc=c+step[1];
      while(inBounds(N,nr,nc)&&grid[nr][nc]==="#"){ nr+=step[0]; nc+=step[1]; }
      return inBounds(N,nr,nc)?{r:nr,c:nc}:null;
    };
    const prevCell=({N,grid,r,c,dir})=>{
      const step = dir==="across" ? [0,-1] : [-1,0];
      let nr=r+step[0], nc=c+step[1];
      while(inBounds(N,nr,nc)&&grid[nr][nc]==="#"){ nr+=step[0]; nc+=step[1]; }
      return inBounds(N,nr,nc)?{r:nr,c:nc}:null;
    };

    function usePuzzle(initialPuzzle){
      const [puzzle,setPuzzle]=useState(()=>clone(initialPuzzle));
      const meta=useMemo(()=>generateMeta(puzzle.grid),[puzzle.grid]);
      const [userGrid,setUserGrid]=useState(()=>puzzle.grid.map(row=>row.replace(/[^#]/g," ")));
      const [dir,setDir]=useState("across");
      const [active,setActive]=useState(()=>({r:0,c:0}));
      const [checked,setChecked]=useState(false);
      useEffect(()=>{ setUserGrid(puzzle.grid.map(r=>r.replace(/[^#]/g," "))); setChecked(false); },[puzzle.id]);
      return {puzzle,setPuzzle,meta,userGrid,setUserGrid,dir,setDir,active,setActive,checked,setChecked};
    }

    function getCurrentRun(meta,dir,r,c){
      const runs = dir==="across"?meta.across:meta.down;
      for (const run of runs){
        if (dir==="across"){
          if (r===run.row && c>=run.col && c<run.col+run.length) return run;
        } else {
          if (c===run.col && r>=run.row && r<run.row+run.length) return run;
        }
      }
      return null;
    }
    const coordsOfRun=(run,dir)=>{
      if(!run) return [];
      return Array.from({length:run.length},(_,i)=>dir==="across"
        ? {r:run.row,c:run.col+i} : {r:run.row+i,c:run.col});
    };

    function MiniCell({cell,isActive,inActiveWord,userCh,correct,onClick}){
      if(cell.ch==="#") return <div className="bg-neutral-900 rounded-md" />;
      const base="relative rounded-md border text-center flex items-center justify-center select-none aspect-square";
      const color=isActive?"border-indigo-500 ring-2 ring-indigo-300":inActiveWord?"border-indigo-300":"border-neutral-300";
      const wrong=correct===false?"bg-red-50":""; const right=correct===true?"bg-green-50":"";
      return (
        <button onClick={onClick} className={`${base} ${color} ${wrong} ${right}`}>
          {cell.num && <span className="absolute top-0.5 left-1 text-[10px] text-neutral-500">{cell.num}</span>}
          <span className="text-xl font-semibold">{userCh || " "}</span>
        </button>
      );
    }

    function Controls({onClear,onCheck,onRevealRun,onRevealAll,onImport,onExport}){
      const [importText,setImportText]=useState("");
      return (
        <div className="flex flex-wrap items-center gap-2">
          <button className="px-3 py-1 rounded-md border bg-white" onClick={onClear}>Clear</button>
          <button className="px-3 py-1 rounded-md border bg-white" onClick={onCheck}>Check</button>
          <button className="px-3 py-1 rounded-md border bg-white" onClick={onRevealRun}>Reveal Word</button>
          <button className="px-3 py-1 rounded-md border bg-white" onClick={onRevealAll}>Reveal All</button>
          <div className="w-px h-6 bg-neutral-300 mx-1" />
          <details className="group">
            <summary className="cursor-pointer px-3 py-1 rounded-md border bg-white inline-block">Import / Export</summary>
            <div className="mt-2 p-3 border rounded-md bg-neutral-50 w-[480px] max-w-[90vw]">
              <div className="text-sm mb-1 font-medium">Import JSON</div>
              <textarea className="w-full h-28 p-2 border rounded-md text-xs font-mono"
                        placeholder='{"id":"mine","size":5,"grid":["#####",...],"clues":{"across":{},"down":{}}}'
                        value={importText} onChange={e=>setImportText(e.target.value)} />
              <div className="flex gap-2 mt-2">
                <button className="px-3 py-1 rounded-md border bg-white" onClick={()=>onImport(importText)}>Import</button>
                <button className="px-3 py-1 rounded-md border bg-white" onClick={onExport}>Export Current</button>
              </div>
            </div>
          </details>
        </div>
      );
    }

    function ClueList({title,runs,cluesMap}){
      return (
        <div>
          <h3 className="text-sm uppercase tracking-wide text-neutral-500 mb-2">{title}</h3>
          <div className="space-y-1">
            {runs.map(run=>{
              const txt=(cluesMap && cluesMap[run.number]) || "(add a clue)";
              return (
                <div key={`${title}-${run.number}`} className="px-3 py-2 rounded-md border bg-white">
                  <div className="text-[11px] text-neutral-500">{run.number}</div>
                  <div className="text-sm">{txt}</div>
                  <div className="text-[11px] text-neutral-400 mt-0.5">{run.length} letters</div>
                </div>
              );
            })}
          </div>
        </div>
      );
    }

    function MiniCrosswordApp(){
      const [puzzles,setPuzzles]=useState(SAMPLE_PUZZLES);
      const [currentId,setCurrentId]=useState(SAMPLE_PUZZLES[0].id);
      const currentPuzzle=useMemo(()=>puzzles.find(p=>p.id===currentId),[puzzles,currentId]);
      const {puzzle,setPuzzle,meta,userGrid,setUserGrid,dir,setDir,active,setActive,checked,setChecked}=usePuzzle(currentPuzzle);

      useEffect(()=>{ setPuzzle(clone(currentPuzzle)); },[currentPuzzle.id]);

      const N=meta.N;
      const activeRun=getCurrentRun(meta,dir,active.r,active.c);
      const activeCoords=coordsOfRun(activeRun,dir);
      const gridRef=useRef(null);

      useEffect(()=>{
        const el=gridRef.current; if(!el) return;
        const handler=(e)=>{
          if(!el.contains(document.activeElement)) return;
          const k=e.key;
          if(/^[a-zA-Z]$/.test(k)){
            e.preventDefault();
            if(puzzle.grid[active.r][active.c]==="#") return;
            const next=[...userGrid];
            next[active.r]=setCharAt(next[active.r],active.c,k.toUpperCase());
            setUserGrid(next); setChecked(false);
            const nxt=nextCell({N,grid:puzzle.grid,r:active.r,c:active.c,dir});
            if(nxt) setActive(nxt); return;
          }
          if(k==="Backspace"){
            e.preventDefault();
            const next=[...userGrid];
            const has=userGrid[active.r][active.c]!==" " && puzzle.grid[active.r][active.c]!=="#";
            if(has){ next[active.r]=setCharAt(next[active.r],active.c," "); setUserGrid(next); }
            else {
              const prv=prevCell({N,grid:puzzle.grid,r:active.r,c:active.c,dir});
              if(prv){ next[prv.r]=setCharAt(next[prv.r],prv.c," "); setUserGrid(next); setActive(prv); }
            }
            setChecked(false); return;
          }
          if(k===" "){ e.preventDefault(); setDir(d=>d==="across"?"down":"across"); return; }
          if(k==="Enter"){
            e.preventDefault();
            const runs=dir==="across"?meta.across:meta.down;
            if(!activeRun) return;
            const idx=runs.findIndex(r=>r.number===activeRun.number);
            const nextRun=runs[(idx+1)%runs.length];
            setActive({r:nextRun.row,c:nextRun.col}); return;
          }
          const mv=(dr,dc)=>{ e.preventDefault();
            const nr=Math.max(0,Math.min(N-1,active.r+dr));
            const nc=Math.max(0,Math.min(N-1,active.c+dc));
            if(puzzle.grid[nr][nc]!=="#") setActive({r:nr,c:nc});
          };
          if(k==="ArrowUp")return mv(-1,0);
          if(k==="ArrowDown")return mv(1,0);
          if(k==="ArrowLeft")return mv(0,-1);
          if(k==="ArrowRight")return mv(0,1);
        };
        document.addEventListener("keydown",handler);
        return()=>document.removeEventListener("keydown",handler);
      },[active,dir,userGrid,puzzle.grid,meta]);

      const clearAll=()=>{ setUserGrid(puzzle.grid.map(r=>r.replace(/[^#]/g," "))); setChecked(false); };
      const check=()=>setChecked(true);
      const revealRun=()=>{
        if(!activeRun) return;
        const {row,col,length}=activeRun; const next=[...userGrid];
        if(dir==="across"){ for(let i=0;i<length;i++) next[row]=setCharAt(next[row],col+i,puzzle.grid[row][col+i]); }
        else { for(let i=0;i<length;i++) next[row+i]=setCharAt(next[row+i],col,puzzle.grid[row+i][col]); }
        setUserGrid(next);
      };
      const revealAll=()=>setUserGrid(puzzle.grid.map(r=>r.replace(/#/g,"#")));

      const correctness = useMemo(()=>{
        if(!checked) return null;
        const m=Array.from({length:N},()=>Array(N).fill(null));
        for(let r=0;r<N;r++)for(let c=0;c<N;c++){
          const sol=puzzle.grid[r][c], usr=userGrid[r][c];
          if(sol==="#"){ m[r][c]=null; continue; }
          if(usr===" "){ m[r][c]=false; continue; }
          m[r][c]=usr===sol;
        }
        return m;
      },[checked,userGrid,puzzle.grid]);

      return (
        <div className="p-6 max-w-5xl mx-auto">
          <div className="flex items-end justify-between gap-4">
            <div>
              <h1 className="text-2xl font-semibold">{puzzle.title || "Mini Crossword"}</h1>
              <div className="text-sm text-neutral-500">{puzzle.author ? `by ${puzzle.author}` : ""} {puzzle.date ? `· ${puzzle.date}` : ""}</div>
            </div>
            <Controls
              onClear={clearAll}
              onCheck={check}
              onRevealRun={revealRun}
              onRevealAll={revealAll}
              onImport={(txt)=>{ try{ const obj=JSON.parse(txt); if(!obj.id) obj.id=`import-${Date.now()}`; if(!obj.size||obj.grid?.length!==obj.size) throw new Error("Grid size mismatch"); setPuzzles(p=>[...p,obj]); setCurrentId(obj.id);}catch(e){ alert("Import failed: "+e.message); } }}
              onExport={()=>{ const data=JSON.stringify(puzzle,null,2); const a=document.createElement("a"); a.href=URL.createObjectURL(new Blob([data],{type:"application/json"})); a.download=`${puzzle.title||puzzle.id}.json`; a.click(); }}
            />
          </div>

          <div ref={gridRef} tabIndex={0} className="mt-6 grid grid-cols-1 lg:grid-cols-[minmax(0,400px)_1fr] gap-8 items-start outline-none"
               onKeyDown={(e)=>{ if(e.key===" ") e.preventDefault(); }}>
            <div>
              <div className="grid" style={{gridTemplateColumns:`repeat(${N},minmax(0,1fr))`,gap:"4px"}}>
                {meta.numbering.flatMap((rowNums,r)=>rowNums.map((num,c)=>{
                  const cell={ch:puzzle.grid[r][c],num,row:r,col:c};
                  const isActive=active.r===r&&active.c===c;
                  const inActiveWord=(coordsOfRun(getCurrentRun(meta,dir,active.r,active.c),dir)||[]).some(k=>k.r===r&&k.c===c);
                  const mark=correctness?correctness[r][c]:null;
                  return (
                    cell.ch==="#"
                    ? <div key={`b-${r}-${c}`} className="bg-neutral-900 rounded-md" />
                    : <MiniCell key={`p-${r}-${c}`} cell={cell} isActive={isActive} inActiveWord={inActiveWord}
                        userCh={userGrid[r][c]==="#"?"":userGrid[r][c]}
                        correct={mark}
                        onClick={()=>{ if(puzzle.grid[r][c]==="#") return; if(active.r===r&&active.c===c) setDir(d=>d==="across"?"down":"across"); else setActive({r,c}); }} />
                  );
                }))}
              </div>
              <div className="mt-2 text-xs text-neutral-500">Tip: Type letters. Space = toggle direction. Enter = next clue. Arrows = move.</div>
            </div>
            <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
              <ClueList title="Across" runs={meta.across} cluesMap={puzzle.clues?.across||{}} />
              <ClueList title="Down" runs={meta.down} cluesMap={puzzle.clues?.down||{}} />
            </div>
          </div>
        </div>
      );
    }

    // Boot
    try {
      const root = ReactDOM.createRoot(document.getElementById("root"));
      root.render(<MiniCrosswordApp />);
    } catch (e) {
      document.getElementById("root").innerHTML =
        '<div style="padding:16px;color:#b91c1c">Error starting app: '+e.message+'</div>';
      console.error(e);
    }
  </script>
</body>
</html>
