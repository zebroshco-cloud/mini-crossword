<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Mini Crossword</title>
  <!-- Tailwind (Play CDN) -->
  <script src="https://cdn.tailwindcss.com"></script>
  <!-- React + ReactDOM from CDN -->
  <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
  <!-- Babel for in-browser JSX transform (simple, no build) -->
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
</head>
<body class="bg-white text-neutral-900">
  <div id="root"></div>

  <script type="text/babel">
    const { useMemo, useState, useEffect, useRef } = React;

    // Utilities
    const clone = (x) => JSON.parse(JSON.stringify(x));
    const DIRS = { ACROSS: "across", DOWN: "down" };

    const SAMPLE_PUZZLES = [
      {
        id: "sample-1",
        title: "Morning Warmup",
        author: "You",
        date: "2025-08-27",
        size: 5,
        grid: [
          "CAFE#",
          "AREA#",
          "FRODO",
          "#ECHO",
          "#SOLO",
        ],
        clues: {
          across: {
            "1": "Coffee spot",
            "3": "Zone or field",
            "6": "Baggins of the Shire",
            "7": "Sound reflection",
            "8": "Han ___"
          },
          down: {
            "1": "Car horn sound",
            "2": "Exists",
            "4": "Golf peg",
            "5": "Not many"
          }
        }
      },
      {
        id: "blank-5x5",
        title: "Blank Starter",
        author: "",
        date: "2025-08-27",
        size: 5,
        grid: [
          "#####",
          "#####",
          "#####",
          "#####",
          "#####",
        ],
        clues: { across: {}, down: {} }
      }
    ];

    function generateMeta(grid) {
      const N = grid.length;
      const isBlock = (r, c) => grid[r][c] === "#";
      const numbering = Array.from({ length: N }, () => Array(N).fill(null));
      let num = 0;

      for (let r = 0; r < N; r++) {
        for (let c = 0; c < N; c++) {
          const ch = grid[r][c];
          let startsAcross = false;
          let startsDown = false;
          if (ch !== "#") {
            if (c === 0 || grid[r][c - 1] === "#") {
              if (c + 1 < N && grid[r][c + 1] !== "#") startsAcross = true;
            }
            if (r === 0 || grid[r - 1][c] === "#") {
              if (r + 1 < N && grid[r + 1][c] !== "#") startsDown = true;
            }
          }
          if (startsAcross || startsDown) {
            num += 1;
            numbering[r][c] = num;
          }
        }
      }

      const across = [];
      for (let r = 0; r < N; r++) {
        let c = 0;
        while (c < N) {
          if (grid[r][c] !== "#" && (c === 0 || grid[r][c - 1] === "#")) {
            let startC = c;
            let letters = "";
            while (c < N && grid[r][c] !== "#") {
              letters += grid[r][c];
              c++;
            }
            if (letters.length > 1) {
              across.push({ number: numbering[r][startC], row: r, col: startC, length: letters.length, answer: letters });
            }
          } else {
            c++;
          }
        }
      }

      const down = [];
      for (let c = 0; c < N; c++) {
        let r = 0;
        while (r < N) {
          if (grid[r][c] !== "#" && (r === 0 || grid[r - 1][c] === "#")) {
            let startR = r;
            let letters = "";
            while (r < N && grid[r][c] !== "#") {
              letters += grid[r][c];
              r++;
            }
            if (letters.length > 1) {
              down.push({ number: numbering[startR][c], row: startR, col: c, length: letters.length, answer: letters });
            }
          } else {
            r++;
          }
        }
      }
      return { N, numbering, across, down };
    }

    function emptyUserGridFrom(grid) { return grid.map((row) => row.replace(/[^#]/g, " ")); }
    function setCharAt(str, idx, ch) { return str.substring(0, idx) + ch + str.substring(idx + 1); }
    function inBounds(N, r, c) { return r >= 0 && r < N && c >= 0 && c < N; }

    function nextCell({ N, grid, r, c, dir }) {
      const step = dir === DIRS.ACROSS ? [0, 1] : [1, 0];
      let nr = r + step[0];
      let nc = c + step[1];
      while (inBounds(N, nr, nc) && grid[nr][nc] === "#") { nr += step[0]; nc += step[1]; }
      if (!inBounds(N, nr, nc)) return null;
      return { r: nr, c: nc };
    }
    function prevCell({ N, grid, r, c, dir }) {
      const step = dir === DIRS.ACROSS ? [0, -1] : [-1, 0];
      let nr = r + step[0];
      let nc = c + step[1];
      while (inBounds(N, nr, nc) && grid[nr][nc] === "#") { nr += step[0]; nc += step[1]; }
      if (!inBounds(N, nr, nc)) return null;
      return { r: nr, c: nc };
    }

    function usePuzzle(initialPuzzle) {
      const [puzzle, setPuzzle] = useState(() => clone(initialPuzzle));
      const meta = useMemo(() => generateMeta(puzzle.grid), [puzzle.grid]);
      const [userGrid, setUserGrid] = useState(() => emptyUserGridFrom(puzzle.grid));
      const [dir, setDir] = useState(DIRS.ACROSS);
      const [active, setActive] = useState(() => {
        for (let r = 0; r < meta.N; r++) for (let c = 0; c < meta.N; c++) if (puzzle.grid[r][c] !== "#") return { r, c };
        return { r: 0, c: 0 };
      });
      const [checked, setChecked] = useState(false);
      useEffect(() => {
        setUserGrid(emptyUserGridFrom(puzzle.grid));
        setChecked(false);
        for (let r = 0; r < meta.N; r++) for (let c = 0; c < meta.N; c++) if (puzzle.grid[r][c] !== "#") { setActive({ r, c }); return; }
      }, [puzzle.id]);
      return { puzzle, setPuzzle, meta, userGrid, setUserGrid, dir, setDir, active, setActive, checked, setChecked };
    }

    function getCurrentRun(meta, dir, r, c) {
      const runs = dir === DIRS.ACROSS ? meta.across : meta.down;
      for (const run of runs) {
        const { row, col, length } = run;
        if (dir === DIRS.ACROSS) { if (r === row && c >= col && c < col + length) return run; }
        else { if (c === col && r >= row && r < row + length) return run; }
      }
      return null;
    }
    function coordsOfRun(run, dir) {
      const coords = [];
      if (!run) return coords;
      for (let i = 0; i < run.length; i++) coords.push(dir === DIRS.ACROSS ? { r: run.row, c: run.col + i } : { r: run.row + i, c: run.col });
      return coords;
    }

    function MiniCell({ cell, isActive, inActiveWord, userCh, correct, onClick }) {
      const { ch, num } = cell;
      if (ch === "#") return <div className="bg-neutral-900 rounded-md" />;
      const base = "relative rounded-md border text-center flex items-center justify-center select-none aspect-square";
      const color = isActive ? "border-indigo-500 ring-2 ring-indigo-300" : inActiveWord ? "border-indigo-300" : "border-neutral-300";
      const wrong = correct === false ? "bg-red-50" : "";
      const right = correct === true ? "bg-green-50" : "";
      return (
        <button onClick={onClick} className={`${base} ${color} ${wrong} ${right}`} aria-label={`Cell ${num ?? ''}`}>
          {num && (<span className="absolute top-0.5 left-1 text-[10px] text-neutral-500 select-none">{num}</span>)}
          <span className="text-xl font-semibold tracking-wide">{(userCh || " ")}</span>
        </button>
      );
    }

    function Controls({ onClear, onCheck, onRevealRun, onRevealAll, onImport, onExport }) {
      const [importText, setImportText] = useState("");
      return (
        <div className="flex flex-wrap items-center gap-2">
          <button className="px-3 py-1 rounded-md border bg-white" onClick={onClear}>Clear</button>
          <button className="px-3 py-1 rounded-md border bg-white" onClick={onCheck}>Check</button>
          <button className="px-3 py-1 rounded-md border bg-white" onClick={onRevealRun}>Reveal Word</button>
          <button className="px-3 py-1 rounded-md border bg-white" onClick={onRevealAll}>Reveal All</button>
          <div className="w-px h-6 bg-neutral-300 mx-1" />
          <details className="group">
            <summary className="cursor-pointer px-3 py-1 rounded-md border bg-white inline-block">Import / Export</summary>
            <div className="mt-2 p-3 border rounded-md bg-neutral-50 w-[480px] max-w-[90vw]">
              <div className="text-sm mb-1 font-medium">Import JSON</div>
              <textarea className="w-full h-28 p-2 border rounded-md text-xs font-mono" placeholder="Paste a puzzle JSON here and click Import" value={importText} onChange={(e) => setImportText(e.target.value)} />
              <div className="flex gap-2 mt-2">
                <button className="px-3 py-1 rounded-md border bg-white" onClick={() => onImport(importText)}>Import</button>
                <button className="px-3 py-1 rounded-md border bg-white" onClick={onExport}>Export Current</button>
              </div>
              <div className="text-[11px] text-neutral-500 mt-2">
                JSON shape: {"{"}{"{"id","title","author","date","size","grid":["#####",...],"clues":{"across":{"1":"..."},"down":{}}}"}{"}"}
              </div>
            </div>
          </details>
        </div>
      );
    }

    function ClueList({ title, runs, cluesMap, activeNumber, onSelect }) {
      return (
        <div>
          <h3 className="text-sm uppercase tracking-wide text-neutral-500 mb-2">{title}</h3>
          <div className="space-y-1">
            {runs.map((run) => {
              const key = run.number?.toString();
              const text = (cluesMap && key && cluesMap[key]) || "(add a clue)";
              const isActive = activeNumber === run.number;
              return (
                <button key={`${title}-${run.number}`} onClick={() => onSelect(run)} className={`w-full text-left px-3 py-2 rounded-md border ${isActive ? 'bg-indigo-50 border-indigo-300' : 'bg-white border-neutral-200 hover:bg-neutral-50'}`}>
                  <div className="text-[11px] text-neutral-500">{run.number}</div>
                  <div className="text-sm leading-snug">{text}</div>
                  <div className="text-[11px] text-neutral-400 mt-0.5">{run.length} letters</div>
                </button>
              );
            })}
          </div>
        </div>
      );
    }

    function MiniCrosswordApp() {
      const [puzzles, setPuzzles] = useState(SAMPLE_PUZZLES);
      const [currentId, setCurrentId] = useState(SAMPLE_PUZZLES[0].id);
      const currentPuzzle = useMemo(() => puzzles.find(p => p.id === currentId), [puzzles, currentId]);
      const { puzzle, setPuzzle, meta, userGrid, setUserGrid, dir, setDir, active, setActive, checked, setChecked } = usePuzzle(currentPuzzle);

      useEffect(() => { setPuzzle(clone(currentPuzzle)); }, [currentPuzzle.id]);
      const N = meta.N;
      const activeRun = getCurrentRun(meta, dir, active.r, active.c);
      const activeCoords = (function(run, dir){ const a=[]; if(!run) return a; for(let i=0;i<run.length;i++){ a.push(dir===DIRS.ACROSS?{r:run.row,c:run.col+i}:{r:run.row+i,c:run.col}); } return a; })(activeRun, dir);
      const activeNumber = activeRun?.number ?? null;
      const gridRef = useRef(null);

      useEffect(() => {
        const el = gridRef.current; if (!el) return;
        const handler = (e) => {
          if (!el.contains(document.activeElement)) return;
          const key = e.key;
          if (/^[a-zA-Z]$/.test(key)) {
            e.preventDefault();
            const ch = key.toUpperCase();
            if (puzzle.grid[active.r][active.c] === '#') return;
            const next = [...userGrid];
            next[active.r] = setCharAt(next[active.r], active.c, ch);
            setUserGrid(next);
            setChecked(false);
            const nxt = nextCell({ N, grid: puzzle.grid, r: active.r, c: active.c, dir });
            if (nxt) setActive(nxt);
            return;
          }
          if (key === 'Backspace') {
            e.preventDefault();
            const hasLetter = userGrid[active.r][active.c] !== ' ' && puzzle.grid[active.r][active.c] !== '#';
            const next = [...userGrid];
            if (hasLetter) {
              next[active.r] = setCharAt(next[active.r], active.c, ' ');
              setUserGrid(next);
            } else {
              const prv = prevCell({ N, grid: puzzle.grid, r: active.r, c: active.c, dir });
              if (prv) {
                next[prv.r] = setCharAt(next[prv.r], prv.c, ' ');
                setUserGrid(next);
                setActive(prv);
              }
            }
            setChecked(false);
            return;
          }
          if (key === ' ') { e.preventDefault(); setDir((d) => d === DIRS.ACROSS ? DIRS.DOWN : DIRS.ACROSS); return; }
          if (key === 'Enter') {
            e.preventDefault();
            const runs = dir === DIRS.ACROSS ? meta.across : meta.down;
            if (!activeRun) return;
            const idx = runs.findIndex(r => r.number === activeRun.number);
            const nextRun = runs[(idx + 1) % runs.length];
            setActive({ r: nextRun.row, c: nextRun.col });
            return;
          }
          const mv = (dr, dc) => {
            e.preventDefault();
            const nr = Math.max(0, Math.min(N - 1, active.r + dr));
            const nc = Math.max(0, Math.min(N - 1, active.c + dc));
            if (puzzle.grid[nr][nc] !== '#') setActive({ r: nr, c: nc });
          };
          if (key === 'ArrowUp') return mv(-1, 0);
          if (key === 'ArrowDown') return mv(1, 0);
          if (key === 'ArrowLeft') return mv(0, -1);
          if (key === 'ArrowRight') return mv(0, 1);
        };
        document.addEventListener('keydown', handler);
        return () => document.removeEventListener('keydown', handler);
      }, [active, dir, userGrid, puzzle.grid, meta]);

      const clearAll = () => { setUserGrid(emptyUserGridFrom(puzzle.grid)); setChecked(false); };
      const check = () => { setChecked(true); };
      const revealRun = () => {
        if (!activeRun) return;
        const { row, col, length } = activeRun;
        const next = [...userGrid];
        if (dir === DIRS.ACROSS) {
          for (let i = 0; i < length; i++) next[row] = setCharAt(next[row], col + i, puzzle.grid[row][col + i]);
        } else {
          for (let i = 0; i < length; i++) next[row + i] = setCharAt(next[row + i], col, puzzle.grid[row + i][col]);
        }
        setUserGrid(next);
      };
      const revealAll = () => { setUserGrid(puzzle.grid.map(row => row.replace(/#/g, '#'))); };
      const handleCellClick = (r, c) => { if (puzzle.grid[r][c] === '#') return; if (active.r === r && active.c === c) setDir((d) => d === DIRS.ACROSS ? DIRS.DOWN : DIRS.ACROSS); else setActive({ r, c }); };
      const onImport = (text) => {
        try {
          const obj = JSON.parse(text);
          if (!obj.id) obj.id = `import-${Date.now()}`;
          if (!obj.size || obj.grid?.length !== obj.size) throw new Error('Grid size mismatch');
          setPuzzles((prev) => [...prev, obj]);
          setCurrentId(obj.id);
        } catch (e) { alert(`Import failed: ${e.message}`); }
      };
      const onExport = () => {
        const data = JSON.stringify(puzzle, null, 2);
        const a = document.createElement('a');
        a.href = URL.createObjectURL(new Blob([data], { type: 'application/json' }));
        a.download = `${puzzle.title || puzzle.id}.json`;
        a.click();
      };

      const metaN = meta.N;
      const correctness = React.useMemo(() => {
        if (!checked) return null;
        const marks = Array.from({ length: metaN }, () => Array(metaN).fill(null));
        for (let r = 0; r < metaN; r++) {
          for (let c = 0; c < metaN; c++) {
            const sol = puzzle.grid[r][c];
            const usr = userGrid[r][c];
            if (sol === '#') { marks[r][c] = null; continue; }
            if (usr === ' ') { marks[r][c] = false; continue; }
            marks[r][c] = usr === sol;
          }
        }
        return marks;
      }, [checked, userGrid, puzzle.grid]);

      const gridUI = (
        <div ref={gridRef} tabIndex={0} className="outline-none" onKeyDown={(e) => { if (e.key === ' ') e.preventDefault(); }}>
          <div className="grid" style={{ gridTemplateColumns: `repeat(${N}, minmax(0, 1fr))`, gap: '4px' }}>
            {meta.numbering.flatMap((rowNums, r) => (
              rowNums.map((num, c) => {
                const cell = { ch: puzzle.grid[r][c], num, row: r, col: c };
                const isActive = active.r === r && active.c === c;
                const inActiveWord = (function(){ return (activeCoords || []).some(k => k.r === r && k.c === c); })();
                const correctMark = correctness ? correctness[r][c] : null;

                if (puzzle.grid[r][c] === '#') {
                  return <div key={`b-${r}-${c}`} className="bg-neutral-900 rounded-md" />;
                }
                return (
                  <MiniCell
                    key={`p-${r}-${c}`}
                    cell={cell}
                    isActive={isActive}
                    inActiveWord={inActiveWord}
                    userCh={userGrid[r][c] === '#' ? '' : userGrid[r][c]}
                    correct={correctMark}
                    onClick={() => handleCellClick(r, c)}
                  />
                );
              })
            ))}
          </div>
          <div className="mt-2 text-xs text-neutral-500">Tip: Type letters. Space = toggle direction. Enter = next clue. Arrows = move.</div>
        </div>
      );

      const header = (
        <div className="flex items-end justify-between gap-4">
          <div>
            <h1 className="text-2xl font-semibold">{puzzle.title || 'Mini Crossword'}</h1>
            <div className="text-sm text-neutral-500">{puzzle.author ? `by ${puzzle.author}` : ''} {puzzle.date ? `· ${puzzle.date}` : ''}</div>
          </div>
          <Controls
            onClear={clearAll}
            onCheck={check}
            onRevealRun={revealRun}
            onRevealAll={revealAll}
            onImport={onImport}
            onExport={onExport}
          />
        </div>
      );

      return (
        <div className="p-6 max-w-5xl mx-auto">
          {header}
          <div className="mt-6 grid grid-cols-1 lg:grid-cols-[minmax(0,400px)_1fr] gap-8 items-start">
            {gridUI}
            <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
              <ClueList title="Across" runs={meta.across} cluesMap={puzzle.clues?.across || {}} activeNumber={null} onSelect={()=>{}} />
              <ClueList title="Down" runs={meta.down} cluesMap={puzzle.clues?.down || {}} activeNumber={null} onSelect={()=>{}} />
            </div>
          </div>
        </div>
      );
    }

    const root = ReactDOM.createRoot(document.getElementById('root'));
    root.render(<MiniCrosswordApp />);
  </script>
</body>
</html>
